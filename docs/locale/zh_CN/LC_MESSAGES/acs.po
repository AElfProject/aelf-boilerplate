# SOME DESCRIPTIVE TITLE.
# Copyright (C) todo
# This file is distributed under the same license as the AElf package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
msgid ""
msgstr ""
"Project-Id-Version: AElf 1.0.0-Preview3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-06-19 09:05+0800\n"
"PO-Revision-Date: 2020-06-19 09:08+0800\n"
"Last-Translator: \n"
"Language: zh_CN\n"
"Language-Team: \n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"
"X-Generator: Poedit 2.3.1\n"

#: ../acs/acs1.md:1
msgid "ACS1 - Transaction Fee Standard"
msgstr "ACS1 - 交易费标准"

#: ../acs/acs1.md:3
msgid "ACS1 is used to manage the transfer fee."
msgstr "ACS1用于管理交易的手续费。"

#: ../acs/acs1.md:5 ../acs/acs10.md:5 ../acs/acs2.md:5 ../acs/acs3.md:11 ../acs/acs4.rst:7 ../acs/acs5.md:5 ../acs/acs8.md:9 ../acs/acs9.md:5
msgid "Interface"
msgstr "接口"

#: ../acs/acs1.md:7
msgid "The contract inherited from ACS1 need implement the APIs below:"
msgstr "继承了ACS1的合约需要实现以下接口："

#: ../acs/acs1.md:9
msgid "SetMethodFee, the parameter type MethodFees defined in acs1.proto indicates the method name and its fee."
msgstr "SetMethodFee，参数为acs1.proto中自定义的MethodFees类型，用于设置该合约中某个方法的Method Fee，即交易费信息。"

#: ../acs/acs1.md:11
msgid "GetMethodFee is used to get the method fee according to your input(method name)."
msgstr "GetMethodFee，参数为protobuf中的StringValue类型，返回值是MethodFees类型，用于获取某个方法的Method Fee。"

#: ../acs/acs1.md:13
msgid "ChangeMethodFeeController is used to set who has the ablitity to call SetMethodFee, and its parameter's type AuthorityInfo is defined in authority_info.proto."
msgstr ""
"ChangeMethodFeeController，参数为authority_info.proto中定义的AuthorityInfo类型，由于理论上不允许每个人都能够设置交易费，因此SetMethodFee这个方法的调用需要配置权限，该方法用于修改能够调用SetMethodFee方法"
"的账户地址。"

#: ../acs/acs1.md:15
msgid "GetMehodFeeController is used to get who has the ablitity to call SetMethodFee."
msgstr "GetMethodFeeController，用于获取该合约SetMethodFee调用权限相关的的AuthorityInfo信息。"

#: ../acs/acs1.md:17
msgid "Attention: just the system contract on main chain is able to implement acs1."
msgstr "注意：仅有主链的系统合约才能实现ACS1。"

#: ../acs/acs1.md:19 ../acs/acs10.md:32 ../acs/acs2.md:32 ../acs/acs4.rst:52 ../acs/acs5.md:42 ../acs/acs8.md:27
msgid "Usage"
msgstr "应用"

#: ../acs/acs1.md:21
msgid "On AElf main chain, before a transactoin start to execute, a pre-transaction is generated by pre-plugin FeeChargePreExecutionPlugin. It is used to charge the transaction fee."
msgstr "在AElf主链中，每当执行一个交易的时候，会通过FeeChargePreExecutionPlugin来为该交易生成一个pre-plugin交易；新生成的交易会在原交易之前执行，其作用就是收取原交易发送者一定数额的交易费。"

#: ../acs/acs1.md:23
msgid "The generated transaction's method  is ChargeTransactionFees. The implementation is roughly like that (part of the code is omitted):"
msgstr "新生成的交易对应的合约方法为ChargeTransactionFees，实现大致为（省略了部分代码）："

#: ../acs/acs1.md:69
msgid "In this method, the transaction fee consists of two parts:"
msgstr "该方法分为两部分来收取交易费："

#: ../acs/acs1.md:71
msgid ""
"The system calls GetMethodFee(line 15) to get the transacion fee you should pay. Then, it will check whether your balance is enough. If your balance is sufficient, the fee will be signed in the bill "
"(variant bill). If not, your transaction will be rejected."
msgstr ""
"首先调用原交易目标合约的GetMethodFee方法（15行），获取要收取的费用，随后查询交易发送者的对应额度是否足够，如果足够的话就将这一部分费用（命名为Base Fee）计入账单（bill变量），不够的话意味着交易费收取失"
"败，原交易因此不会被执行。"

#: ../acs/acs1.md:73
msgid "If the method fee is not set to 0 by the contract developer, the system will charge size fee. (the size if calculate by the paramter's size)"
msgstr "随后判断原合约的开发者是否故意将交易中对应的方法的手续费设置为0，如果故意设置为0则不需要进一步收取Size Fee，否则要根据交易的大小收取一笔Size Fee。"

#: ../acs/acs1.md:75
msgid "After charging successfully, an TransactionFeeCharged event is thrown, and the balance of the sender is modified."
msgstr "两部分费用收取成功后，就会直接修改交易发送者的对应token的余额，同时抛出一个TransactionFeeCharged事件。"

#: ../acs/acs1.md:77
#, python-format
msgid ""
"The TransactionFeeCharged event will be captured and processed on the chain to calculate the total amount of transaction fees charged in the block. In the next block, the 10% of the transaction fee "
"charged in this block is destroyed, the remaining 90% flows to dividend pool on the main chain, and is transferred to the FeeReciever on the side chain. The code is:"
msgstr ""
"链上会捕获并处理该事件，计算该区块中收取的交易费的总额度，在下一个区块中，会通过一个名为ClaimTransactionFees的系统交易，将所有该区块中收取的交易费销毁百分之10，其余百分之90区分主侧链，主链会打入主链分红"
"池，侧链会打给事先设定的FeeReceiver地址。具体代码为："

#: ../acs/acs1.md:137
#, fuzzy
msgid "In this way, AElf charges the transaction fee via the GetMethodFee provided by ACS1, and the other three methods are used to help with the implementations of GetMethodFee."
msgstr "如此，AElf通过ACS1提供的GetMethodFee接口来实现整个交易费收费流程，而另外三个接口都是用于辅助GetMethodFee的实现而存在。"

#: ../acs/acs1.md:139 ../acs/acs2.md:50 ../acs/acs3.md:70 ../acs/acs5.md:87 ../acs/acs9.md:34
msgid "Implementation"
msgstr "接口实现"

#: ../acs/acs1.md:141
msgid "The easiest way to do this is to just implement the method GetMethodFee."
msgstr "最简单的方法就是仅实现GetMethodFee接口。"

#: ../acs/acs1.md:143
msgid ""
"If there are Foo1, Foo2, Bar1 and Bar2 methods related to business logic in a contract, they are priced as 1, 1, 2, 2 ELF respectively, and the transaction fees of these four methods will not be easily "
"modified later, they can be implemented as follows:"
msgstr "假如某个合约中事关业务逻辑的方法有Foo1、Foo2、Bar1、Bar2四个，定价分别为1、1、2、2个ELF，且这四个方法的交易费以后不会轻易修改的话，可以实现为："

#: ../acs/acs1.md:182
msgid "This implementation can modify the transaction fee only by upgrading the contract, without implementing the other three interfaces."
msgstr "这种实现仅可以通过升级合约来修改交易费，不过无需实现另外三个接口。"

#: ../acs/acs1.md:184
msgid "A more recommended implementation needs to define an MappedState in the State file for the contract:"
msgstr "而较为推荐的实现需要在该合约的State文件中定义一个MappedState："

#: ../acs/acs1.md:190
msgid "Modify the TransactionFees data structure in the SetMethodFee method, and return the value in the GetMethodFee method."
msgstr "在SetMethodFee方法中修改TransactionFees这个数据结构，在GetMethodFee方法中直接返回该数据结构中的值。"

#: ../acs/acs1.md:192
msgid "In this solution, the implementation of GetMethodFee is very easy:"
msgstr "这个方案中，GetMethodFee的实现极其简单："

#: ../acs/acs1.md:200
msgid ""
"The implementation of SetMethodFee requires the addition of permission management, since contract developers don't want the transaction fees of their contract methods to be arbitrarily modified by "
"others."
msgstr "而SetMethodFee的实现则需要加入权限管理，毕竟合约开发者不会希望自己的合约方法的交易费被别人随意修改。"

#: ../acs/acs1.md:202
msgid "Referring to the MultiToken contract, it can be implemented as follows:"
msgstr "参考MultiToken合约，可以实现为："

#: ../acs/acs1.md:204
msgid "Firstly, define a SingletonState AuthorityInf(the AuthorityInf is defined in authority_info.proto)"
msgstr "首先在State文件中定义一个单例的AuthorityInfo类型（定义在authority_info.proto中）："

#: ../acs/acs1.md:210
msgid "Then, check the sender's right by comparing its address with OwnerAdress."
msgstr "然后使用该类型的OwnerAddress判断Sender是否为指定的地址。"

#: ../acs/acs1.md:226
msgid "AssertValidToken checks if the token symbol exists, and the BasicFee is reasonable."
msgstr "其中AssertValidToken仅仅是看看设置的token是否存在，试图设置的BasicFee是否合理，等等。"

#: ../acs/acs1.md:228
msgid "The permission check code is in the lines 8 and 9, and RequiredMethodFeeControllerSet prevents the permission is not set before."
msgstr "关于权限检查的代码为第8行和第9行，其中RequiredMethodFeeControllerSet仅仅是为了防止权限之前没有设置过。"

#: ../acs/acs1.md:230
msgid ""
"If permissions are not set, the SetMethodFee method can only be called by the default address of the Parliamentary contract. If a method is sent through the default address of Parliament, it means that "
"two-thirds of the block producers have agreed to the proposal."
msgstr "如果没有设置过权限，那就进议会（Parliament）合约的默认地址才能够调用SetMethodFee方法。如果某个方法通过议会的默认地址发出，意味着有2/3的区块生产者同意了相应的提案。"

#: ../acs/acs1.md:251
msgid "Of course, the authority of SetMethodFee can also be changed, provided that the transaction to modify the authority is sent from the default address of the Parliamentary contract:"
msgstr "当然SetMethodFee的调用权限也是能改的，前提是修改权限的交易由议会合约的默认地址发出："

#: ../acs/acs1.md:265
msgid "The implementation of GetMethodFeeController is also very easy："
msgstr "GetMethodFeeController的方法就极为简单了："

#: ../acs/acs1.md:275
msgid ""
"Above all, these are the two ways to implement acs1. Mostly, implementations will use a mixture of the two: part of methods' fee is set to a fixed value, the other part of method is not set method fee."
msgstr "以上为实现ACS1的可能两种的方式，不过大部分实现会使用二者混合：根据使用场景，一部分方法设置一个固定的MethodFee，此时只收取Base Fee，另一部分方法不设置，只收取Size Fee。"

#: ../acs/acs1.md:277 ../acs/acs10.md:206 ../acs/acs2.md:88 ../acs/acs3.md:220 ../acs/acs5.md:125 ../acs/acs9.md:305
msgid "Test"
msgstr "测试"

#: ../acs/acs1.md:279
msgid "Create ACS1's Stub, and call GetMethodFee and GetMethodFeeController to check if the return value is expected."
msgstr "构造相应的Stub，测试GetMethodFee和GetMethodFeeController能够返回预期值即可。"

#: ../acs/acs1.md:281 ../acs/acs10.md:318 ../acs/acs2.md:160
msgid "Example"
msgstr "示例"

#: ../acs/acs1.md:283
msgid "All AElf system contracts implement ACS1, which can be used as a reference."
msgstr "AElf所有的系统合约都实现了ACS1，可以作为参考。"

#: ../acs/acs10.md:1
msgid "ACS10 -  dividend pool standard"
msgstr "ACS10 - 分红池标准"

#: ../acs/acs10.md:3
msgid "ACS10 is used to construct a dividend pool in the contract."
msgstr "ACS10用于在当前合约中构造一个分红池。"

#: ../acs/acs10.md:7
msgid "To construct a dividend pool, you can implement the following interfaces optionally:"
msgstr "为了构造一个分红池，可以可选地实现以下接口："

#: ../acs/acs10.md:9
msgid "Donate is used to donate dividend pool, parameters include the token symbol and the amount to be donated to the dividend pool;"
msgstr "Donate，用于捐赠分红，参数包括要为分红池捐赠的代币symbol和额度;"

#: ../acs/acs10.md:10
msgid "Release is used to release the dividend pool. The parameter is the number of sessions to release dividends. Be careful to set its calling permission."
msgstr "Release，用于释放分红，参数为释放分红的届数，要注意设置其调用权限."

#: ../acs/acs10.md:11
msgid "SetSymbolList is used to set the token symbols dividend pool supports. The parameter is of type SymbolList."
msgstr "SetSymbolList，用于设置分红池所支持的释放分红的代币symbol，参数为SymbolList类型;"

#: ../acs/acs10.md:12
msgid "GetSymbolList is used to get the token symbols dividend pool supports. The return type is SymbolList."
msgstr "GetSymbolList，用于获取分红池所支持的释放分红的代币symbol，返回值为SymbolList类型；"

#: ../acs/acs10.md:13
msgid "GetUndistributdividends is used to obtain tokens' balance that have not been distributed. The return type is Dividends;"
msgstr "GetUndistributedDividends，用于获取尚未被分红的所有分红池所支持的代币余额，返回值为Dividends类型；"

#: ../acs/acs10.md:14
msgid "GetDividends, whose return type is also Dividends, is used to obtain additional dividends from the height of a block."
msgstr "GetDividends，用于获取某个区块高度中新增的分红的额度，返回值也是Dividends类型。"

#: ../acs/acs10.md:16
msgid "SymbolList is a string list:"
msgstr "其中SymbolList类型是string列表："

#: ../acs/acs10.md:24
msgid "The type of Dividends is a map from token symbol to amount:"
msgstr "Dividends类型是key为代币symbol、value为数额的map："

#: ../acs/acs10.md:34
msgid "ACS10 only unifies the standard interface of the dividend pool, which does not interact with the AElf chain."
msgstr "ACS10仅仅是统一了分红池的标准接口，这些接口不会跟AElf链上做交互。"

#: ../acs/acs10.md:36
msgid "Implementaion"
msgstr "接口实现"

#: ../acs/acs10.md:38
msgid "With the Profit contract"
msgstr "借助Profit合约"

#: ../acs/acs10.md:40
msgid "A Profit Scheme can be created using the Profit contract's CreateScheme method:"
msgstr "可以在初始化该合约的时候，使用Profit合约的CreateScheme方法创建一个分红方案（Profit Scheme）："

#: ../acs/acs10.md:56
msgid ""
"The Context.GenerateId method is a common method used by the AElf to generate Id. We use the address of the Profit contract and the schemeToken provided to the Profit contract to calculate the Id of "
"the scheme, and we set this id to State.ProfitSchemeId (SingletonState<Hash>)."
msgstr ""
"其中，schemeToken会被Profit合约用来计算该合约创建的分红方案的Id，Context.GenerateId方法是AElf智能合约通用的用于产生Id的方法，我们使用Profit合约的地址和提供给Profit合约的schemeToken即可自行计算出该分红方"
"案的Id，设置到State.ProfitSchemeId上（这是一个SingletonState<Hash>类型的属性）。"

#: ../acs/acs10.md:58
msgid "After the establishment of the dividend scheme:"
msgstr "创建完分红方案后："

#: ../acs/acs10.md:60
msgid "ContributeProfits method of Profit can be used to implement the method Donate in ACS10."
msgstr "可使用Profit合约的ContributeProfits方法来实现ACS10接口中的Donate方法；"

#: ../acs/acs10.md:61
msgid "The Release in the ACS10 can be implemented using the method DistributeProfits in the Profit contract;"
msgstr "可使用Profit合约的DistributeProfits方法来实现ACS10接口中的Release方法；"

#: ../acs/acs10.md:62
msgid "Methods such as AddBeneficiary and RemoveBeneficiary can be used to manage the recipients and their weight."
msgstr "可使用AddBeneficiary、RemoveBeneficiary等方法来自行管理分红的领取人及权重；"

#: ../acs/acs10.md:63
msgid "AddSubScheme, RemoveSubScheme and other methods can be used to manage the sub-dividend scheme and its weight;"
msgstr "可使用AddSubScheme、RemoveSubScheme等方法自行管理分红关联的子分红方案及权重；"

#: ../acs/acs10.md:64
msgid "The SetSymbolList and GetSymbolList can be implemented by yourself. Just make sure the symbol list you set is used correctly in Donate and Release."
msgstr "SetSymbolList和GetSymbolList中的SymbolList类型可以自行记录，在Donate和Release时发挥对应的作用即可；"

#: ../acs/acs10.md:65
msgid "GetUndistributedDividends returns the balance of the token whose symbol is includeded in symbol list."
msgstr "GetUndistributedDividends方法返回查询到的对应的分红方案总账上SymbolList中包含代币的余额即可。"

#: ../acs/acs10.md:67
msgid "With TokenHolder Contract"
msgstr "借助Token Holder合约"

#: ../acs/acs10.md:69
msgid "When initializing the contract, you should create a token holder dividend scheme using the CreateScheme in the TokenHolder contract(Token Holder Profit Scheme）："
msgstr "在初始化该合约时，使用TokenHolder合约的CreateScheme方法创建一个持币人分红方案（Token Holder Profit Scheme）："

#: ../acs/acs10.md:82
msgid "In a token holder dividend scheme, a scheme is bound to its creator, so SchemeId is not necessary to compute (in fact, the scheme is created via the Profit contract)."
msgstr "在持币人分红方案中，一个分红方案的实例与其创建者绑定，因此无需计算SchemeId（虽然其底层还是通过在Profit合约中创建分红方案实现的，但是这个关系被记录在TokenHolder合约中）。"

#: ../acs/acs10.md:84
msgid "Considering the GetDividends returns the dividend information according to the input height, so each Donate need update dividend information for each height . A Donate can be implemented as:"
msgstr "考虑GetDividends的作用为记录每个区块高度该分红池的收益增长，因此需要在Donate的时候记录下来。Donate可以实现为："

#: ../acs/acs10.md:139
msgid "The method Release directly sends the TokenHolder's method DistributeProfits transaction:"
msgstr "对应的Release直接调用TokenHolder的DistributeProfits方法即可："

#: ../acs/acs10.md:152
msgid ""
"In the TokenHolder contract, the default implementation is to release what token is received, so SetSymbolList does not need to be implemented, and GetSymbolList returns the symbol list recorded in "
"dividend scheme:"
msgstr "在持币人分红合约中，默认实现为收到什么代币的捐赠，就释放什么代币，因此SetSymbolList无需实现，GetSymbolList直接读取分红方案中记录的收到捐赠的代币种类即可："

#: ../acs/acs10.md:184
msgid "The implementation of GetUndistributdividendeds is the same as described in the previous section, and it returns the balance:"
msgstr "GetUndistributedDividends的实现同上一节所述，查询余额返回即可："

#: ../acs/acs10.md:204
msgid "In addition to the Profit and TokenHolder contracts, of course, you can also implement a dividend pool on your own contract."
msgstr "除了借助Profit合约和TokenHolder合约，当然也可以自己实现一个分红池，满足接口的语义即可。"

#: ../acs/acs10.md:208
msgid "The dividend pool, for example, is tested in two ways with the token Holder contract."
msgstr "以借助Token Holder合约实现的分红池为例，分两条线进行测试。"

#: ../acs/acs10.md:210
msgid "One way is for the dividend pool to send Donate, Release and a series of query operations;"
msgstr "一是针对该分红池进行Donate、Release和一系列查询操作；"

#: ../acs/acs10.md:212
msgid "The other way is to use an account to lock up, and then take out dividends."
msgstr "二是使用一个账户进行锁仓，然后取出分红。"

#: ../acs/acs10.md:214
msgid "Define the required Stubs:"
msgstr "定义好需要用到的Stub："

#: ../acs/acs10.md:229
msgid "Before proceeding, You should Approve the TokenHolder contract and the dividend pool contract."
msgstr "在进行操作之前，先对TokenHolder合约和实现了分红池的合约进行一下额度授权。"

#: ../acs/acs10.md:246
msgid "Lock the position, at which point the account balance is reduced by 10 ELF:"
msgstr "锁仓，此时账户余额减少10ELF："

#: ../acs/acs10.md:256
msgid "Donate, at which point the account balance is reduced by another 10 ELF:"
msgstr "捐赠分红，此时账户余额再次减少10ELF："

#: ../acs/acs10.md:266
msgid "At this point you can test the GetUndistributedDividends and GetDividends:"
msgstr "此时就可以测试GetUndistributedDividends和GetDividends接口了："

#: ../acs/acs10.md:282
msgid "Release bonus, and test GetUndistributedDividends again:"
msgstr "释放分红，顺便再次测试GetUndistributedDividends接口是否做出来反应："

#: ../acs/acs10.md:297
msgid "Finally, let this account receive the dividend and then observe the change in its balance:"
msgstr "最后让这个账户领取分红，然后观察其账户余额变动："

#: ../acs/acs10.md:320
msgid "The dividend pool of the main chain and the side chain is built by implementing ACS10."
msgstr "当前主链分红池和侧链分红池都是通过实现ACS10来构建的。"

#: ../acs/acs10.md:322
msgid "The dividend pool provided by the Treasury contract implementing ACS10 is on the main chain."
msgstr "Treasury合约对ACS10的实现为主链分红池。"

#: ../acs/acs10.md:324
msgid "The dividend pool provided by the ACS10 contract implementing ACS10 is on the side chain."
msgstr "AEDPoS合约对ACS10的实现为侧链分红池。"

#: ../acs/acs2.md:1
msgid "ACS2 - Parallel Execution Standard"
msgstr "ACS2 - 并行执行标准"

#: ../acs/acs2.md:3
msgid "ACS2 is used to provide information for parallel execution of transactions."
msgstr "ACS2用于提供交易并行执行的信息。"

#: ../acs/acs2.md:7
msgid "A contract that inherits ACS2 only needs to implement one method:"
msgstr "继承了ACS2的合约仅需要实现一个接口："

#: ../acs/acs2.md:9
msgid "GetResourceInfo"
msgstr ""

#: ../acs/acs2.md:11
msgid "The parameter is the Transaction type, and the return value is the type ResourceInfo defined in acs2.proto:"
msgstr "参数为Transaction类型，返回值为定义在acs2.proto中的ResourceInfo类型："

#: ../acs/acs2.md:20
msgid "aelf.ScopedStatePath is defined in aelf\\core.proto:"
msgstr "其中，aelf.ScopedStatePath定义在aelf\\core.proto中："

#: ../acs/acs2.md:34
msgid "AElf uses the key-value database to store data. For the data generated during the contract execution, a mechanism called State Path is used to determine the key of the data."
msgstr "AElf使用key-value数据库来存储数据，对于合约执行过程中产生的数据，使用一种名为State Path的机制来确定某一条有意义的数据的key。"

#: ../acs/acs2.md:36
msgid "For example Token contract‘s State file defines a property MappedState < Address, string, long >Balances, it can be used to access, modify balance."
msgstr "例如在Token合约的State文件中中定义一个类型为MappedState<Address, string, long>、名为Balances的属性，我们可以通过该属性来访问、修改某一个Address所代表的账户下的某种token的余额。"

#: ../acs/acs2.md:38
msgid ""
"Assuming that the address of the Token contract is Nmjj7noTpMqZ522j76SDsFLhiKkThv1u3d4TxqJMD8v89tWmE. If you want to know the balance of the address 2EM5uV6bSJh6xJfZTUa1pZpYsYcCUAdPvZvFUJzMDJEx3rbioz, "
"you can directly use this key to access redis / ssdb to get its value."
msgstr "假设Token合约的地址为Nmjj7noTpMqZ522j76SDsFLhiKkThv1u3d4TxqJMD8v89tWmE，想要知道地址为2EM5uV6bSJh6xJfZTUa1pZpYsYcCUAdPvZvFUJzMDJEx3rbioz的账户的ELF余额，可以直接使用这个key来访问redis/ssdb："

#: ../acs/acs2.md:44
msgid ""
"On AElf, the implementation of parallel transaction execution is also based on the key , developers need to provide a method may access to the StatePath, then the corresponding transactions will be "
"properly grouped before executing: if the two methods do not access the same StatePath, then you can safely place them in different groups."
msgstr ""
"而在AElf中，交易并行执行的实现也是基于以上key的组织逻辑，开发者需要提供某个方法可能访问到的StatePath，那么这个方法对应的交易在执行之前，会得到适当的分组：如果两个方法不会访问同样的StatePath，那么就可以"
"放心地放在不同的组中。"

#: ../acs/acs2.md:46
msgid "Attention: The transaction will be canceled and labeled to \"can not be groupped\" when the StatePath mismatchs the method."
msgstr "注意，如果该方法提供的StatePath与实际执行过程使用到的StatePath不一致，会在实际执行的过程中取消并行，并且合约会被标记为不能并行。"

#: ../acs/acs2.md:48
msgid "If you are interested in the logic, you can view the code ITransactionGrouper, as well as IParallelTransactionExecutingService ."
msgstr "如果对相关的逻辑感兴趣，可以查看AElf代码中ITransactionGrouper这个接口的实现，以及IParallelTransactionExecutingService接口的实现。"

#: ../acs/acs2.md:52
msgid "A example: within the Token contract, the core logic of method Transfer is to modify the balance of address. It accesses the balances property mentioned above twice."
msgstr "一个例子：Token合约中的Transfer方法，其核心逻辑为修改地址A和地址B的ELF的余额，会访问两次上面提到的Balances属性。"

#: ../acs/acs2.md:54
msgid "At this point, we need to notify ITransactionGrouper via the GetResourceInfo method of the key of the ELF balance of address A and address B:"
msgstr "此时，我们就需要把地址A和地址B的ELF的余额的key通过GetResourceInfo方法通知ITransactionGrouper："

#: ../acs/acs2.md:69
msgid "The GetPath forms a ScopedStatePath from several pieces of data that make up the key:"
msgstr "其中，GetPath就是把组成key的几段数据构成一个ScopedStatePath类型："

#: ../acs/acs2.md:90
msgid ""
"You can construct two transactions, and the transactions are passed directly to an implementation instance of ITransactionGrouper, and the GroupAsync method is used to see if the two transactions are "
"parallel."
msgstr "可以自行构造两个交易，直接将交易ITransactionGrouper的实现实例的GroupAsync方法，来得知这两个交易能否并行。"

#: ../acs/acs2.md:92
msgid "We prepare two stubs that implement the ACS2 contract with different addresses to simulate the Transfer:"
msgstr "我们准备两个实现了ACS2的合约的Stub，它们的地址不同，即模拟不同的地址做Transfer："

#: ../acs/acs2.md:101
msgid "Then take out some services and data needed for testing from Application:"
msgstr "然后从Application中取出测试所需要的一些服务和数据："

#: ../acs/acs2.md:109
msgid "Finally, check it via transactionGrouper:"
msgstr "最后通过transactionGrouper做检验："

#: ../acs/acs2.md:162
msgid ""
"You can refer to the implementation of the MultiToken contract for GetResourceInfo. Noting that for the ResourceInfo provided by the method Tranfer, you need to consider charging a transaction fee in "
"addition to the two keys mentioned in this article."
msgstr "可以参考MultiToken合约对GetResourceInfo的实现，注意其中对于Tranfer方法提供的Resource Info，除了本文提到的两个key，还需要考虑收取交易费。"

#: ../acs/acs3.md:1
msgid "ACS3 - Contract Proposal Standard"
msgstr "ACS3 - 提案合约标准"

#: ../acs/acs3.md:3
msgid "Using the AuthorityInfo defined in authority_info.proto restricts a method to be called by a certain address:"
msgstr "使用authority_info.proto中定义的AuthorityInfo类型配合以下代码可以限制合约的某个方法必须由某一个地址来调用："

#: ../acs/acs3.md:9
#, fuzzy
msgid "When a method needs to be agreed by multiple parties, the above solution is obviously inadequate. At this time, you can consider using some of the interfaces provided by ACS3."
msgstr "当某个方法需要多方同意以后才能调用的话，以上的方案明显捉襟见肘，此时可以考虑使用ACS3提供的部分接口进行实现。"

#: ../acs/acs3.md:13
msgid "If you want multiple addresses vote to get agreement to do something, you can implement the following methods defined in ACS3:"
msgstr "如果要实现多个地址统一某个方案后，该方案能够执行，可以实现ACS3中定义的以下方法："

#: ../acs/acs3.md:15
msgid ""
"CreateProposal, it is to specify a method for a contract and its parameters. When the proposal is approved by multiple addresses, it can be released: use a virtual address as a Sender, and execute this "
"method by sending an inline transaction. Therefore, the parameter CreateProposalInput defines the basic information of the inline transaction to be executed finally. The return value is a hash, which "
"is used to uniquely identify this proposal;"
msgstr ""
"CreateProposal，所谓的Proposal（提案）其实是指定了某个合约某个方法，使用某个参数，当该提案被多个地址同意后，就可以释放：以一个虚拟地址作为Sender，通过发送inline交易来执行这个方法，因此参数"
"CreateProposalInput中定义的是最终要执行的inline交易的基本信息，返回值是一个Hash，用来唯一标识这个提案；"

#: ../acs/acs3.md:16
msgid "Approve, Reject, Abstain, the parameters are Hash, called the proposal Id, created by CreateProposal, is used to agree, reject, and abstain respectively ."
msgstr "Approve、Reject、Abstain，参数都是Hash，即CreateProposal创建出来的提案唯一标识，称之为提案Id，分别用来对某个提案进行同意、反对、弃权。"

#: ../acs/acs3.md:17
msgid "Release, the parameter is the proposal Id, is used to release the proposal: when the requirements are met, it can be released;"
msgstr "Release，参数为提案Id，用于释放提案：当要求达到的话，就可以释放；"

#: ../acs/acs3.md:18
msgid "ClearProposal is used to clean invalid data in DB."
msgstr "ClearProposal，用于清除提案，减少State中存储的信息。"

#: ../acs/acs3.md:20
msgid ""
"It can be seen that before a proposal is released, the account with voting rights can agree, object, and abstain. Which specific accounts have the right to vote? ACS3 introduces the concept of "
"Organization. A proposal is attached to an organization from its creation, and only members of the organization can vote."
msgstr ""
"可以看到，某个提案在释放之前，具备投票权的账户可以进行同意、反对、弃权，而具体哪些账户有权利进行投票呢？ACS3在以上几个接口的基础上，引入了Organization（组织）的概念。也就是说，某个提案从创建开始，就依附"
"于某个组织，而只有该组织的成员才可以进行投票。"

#: ../acs/acs3.md:22
msgid "However, due to the different forms of organization, the Organization structure needs to be defined by the contract implementing the ACS3. Here is an example:"
msgstr "不过由于组织的形式各有不同，因此Organization这个数据结构需要实现了ACS3的合约自行定义，这里给出一个例子："

#: ../acs/acs3.md:34
#, fuzzy
msgid "Because each organization has a default virtual address, adding the code like the begining at this document can verify if the sender is authorized."
msgstr "由于组织拥有一个默认的虚拟地址（上面定义的organization_address），在提案的目标合约方法代码中加入与本文一开头的代码类似的代码，即可以实现某个组织同意调用某个方法的效果："

#: ../acs/acs3.md:40
msgid "How to know what an orgnanization has agreed on a proposal? ACS3 defines a data structure ProposalReleaseThreshold:"
msgstr "怎么知道一个组织对某个提案达成了什么意见？ACS3中定义了一个名为ProposalReleaseThreshold的数据结构："

#: ../acs/acs3.md:51
msgid "The orgnaization determines how to deal with the proposal according to the data:"
msgstr "通过以上的数据结构，来决定这个组织对某个提案达成了什么样的意见，这个提案才能够进行释放："

#: ../acs/acs3.md:53
msgid "the minimal approval the proposal can be released."
msgstr "最少需要有多少票投给了同意；"

#: ../acs/acs3.md:54
msgid "The most rejection amount the proposal can tolerate."
msgstr "最多有多少票投给了反对；"

#: ../acs/acs3.md:55
msgid "The most abstention amount the proposal can tolerate."
msgstr "最多有多少票投给了弃权；"

#: ../acs/acs3.md:56
msgid "the minimal vote amount the proposal is valid."
msgstr "最少需要有多少人参与了投票。"

#: ../acs/acs3.md:58
msgid "Interfaces referencing organization in ACS3:"
msgstr "ACS3中与管理组织相关的接口有："

#: ../acs/acs3.md:60
msgid "ChangeOrganizationThreshold，its paramenter is ProposalReleaseThreshold that is used to modify the threshold. Of course, this method also needs permission control；"
msgstr "ChangeOrganizationThreshold，其参数正是刚提到的ProposalReleaseThreshold，用于修改某个组织的提案被释放之前，需要达到的要求，当然这个方法本身也需要做一下权限控制；"

#: ../acs/acs3.md:61
msgid ""
"ChangeOrganizationProposerWhiteList, The organization can restrict which addresses can create proposals. Its parameter is ProposerWhiteList, defined in acs3.proto, which is actually an Address list;"
msgstr "ChangeOrganizationProposerWhiteList，组织可以限制哪些地址能够发起提案，其参数为ProposerWhiteList，定义在acs3.proto，实际上就是一个Address列表；"

#: ../acs/acs3.md:62
msgid ""
"CreateProposalBySystemContract, The original intention is that the system contract can create a proposal via the virtual address, that is, there are some senders have privileges, and must be a contract:"
msgstr "CreateProposalBySystemContract，本意上是系统合约可以通过这个接口，以别的虚拟地址的名义发起提案，即存在一些Sender存在特权，且Sender必须为某个合约，真正实现的时候，特权合约包括哪些可以自行定义；"

#: ../acs/acs3.md:64
msgid "The type of APIs mentioned above is action, there are some APIs with type View used to query:"
msgstr "以上都是Action类型的接口，还有几个View类型的接口用于查询："

#: ../acs/acs3.md:66
msgid "GetProposal is used to get the proposal detailed information."
msgstr "GetProposal，用于查询提案详情；"

#: ../acs/acs3.md:67
msgid "ValidateOrganizationExist is used to check if the organization exists in a contract."
msgstr "ValidateOrganizationExist，用于查询该合约中是否存在某个组织；"

#: ../acs/acs3.md:68
msgid "ValidateProposerInWhiteList is used to check if the address is in the whitelist of a organization."
msgstr "ValidateProposerInWhiteList，用于查询某个地址是否在某组织的提案白名单（Proposer White List）中。"

#: ../acs/acs3.md:72
msgid ""
"It is assumed here that there is only one organization in a contract, that is, there is no need to specifically define the Organization type. Since the organization is not explicitly declared and "
"created, the organization's proposal whitelist does not exist. The process here is that the voter must use a certain token to vote."
msgstr ""
"这里假设某个合约中只存在一个组织，也就是不需要专门定义Organization类型下，ACS3的实现。由于不会显式声明和创建组织，组织的提案白名单也就不存在。这里的处理方式是投票的人必须使用某种代币进行投票，这样可以在"
"管理该代币的角度限制提案人——具有该代币，就意味着具有投票权。"

#: ../acs/acs3.md:74
msgid "For simplicity, only the core methods CreateProposal, Approve, Reject, Abstain, and Release are implemented here."
msgstr "简单起见，这里只实现CreateProposal、Approve、Reject、Abstain、Release这几个最核心的方法。"

#: ../acs/acs3.md:76
msgid "There are only two necessary State attributes:"
msgstr "必要的State属性只有两个："

#: ../acs/acs3.md:83
#, fuzzy
msgid "The Proposals stores all proposal's information, and the ProposalReleaseThreshold is used to save the requirements that the contract needs to meet to release the proposal."
msgstr "其中，Proposals这个map存放所有的提案详情，而ProposalReleaseThreshold用于保存这个合约释放提案所需要达成的要求。"

#: ../acs/acs3.md:85
msgid "When the contract is initialized, the proposal release requirements should be set:"
msgstr "合约初始化的时候，设置一下最简单的提案释放要求："

#: ../acs/acs3.md:101
msgid "The requirement is at least one member who vote and at least one approval. Create proposal:"
msgstr ""
"翻译一下提案释放要求：至少需要一个人投票，至少需要一个人投同意，即可。\n"
"创建提案："

#: ../acs/acs3.md:123
msgid "Vote:"
msgstr "投票"

#: ../acs/acs3.md:174
msgid "Release is just count the vote, here is a recommended implementation:"
msgstr "释放也只是统计一下这个提案的投票状况，这里给出一个推荐的实现："

#: ../acs/acs3.md:222
msgid "Before testing, two methods were added to the contract, that had just implemented ACS3. We will test the proposal with these mehods."
msgstr "测试之前，在刚刚实现了ACS3的合约中，加入两个方法，用来作为提案的对象。"

#: ../acs/acs3.md:224
msgid "Define a singleton string in the State file:"
msgstr "在State文件中定义一个string类型的单例："

#: ../acs/acs3.md:230
msgid "Then implement a pair of Set/Get methods:"
msgstr "然后实现一对Set/Get方法："

#: ../acs/acs3.md:245
msgid "In this way, during the test, create a proposal for the SetSlogan. After passing and releasing, use the GetSlogan method to check whether the Slogan has been modified."
msgstr "这样，测试的时候对SetSlogan创建提案，通过、释放以后使用GetSlogan方法查看Slogan是否被修改即可。"

#: ../acs/acs3.md:247
msgid "Prepare a Stub that implements the ACS3 contract:"
msgstr "准备一个实现了ACS3的合约的Stub："

#: ../acs/acs3.md:255
msgid "Since approval requires the contract to charge users, the user should send Approve transaction of the Token contract."
msgstr "由于投票需要让合约对用户进行收费，因此需要调用一下Token合约的Approve方法做一下预授权："

#: ../acs/acs3.md:269
msgid "Create a proposal, the target method is SetSlogan, here we want to change the Slogan to \"AElf\" :"
msgstr "创建一个提案，目标方法为SetSlogan，这里我们想把Slogan改成“AElf”："

#: ../acs/acs3.md:282
msgid "Make sure that the Slogan is still an empty string at this time and then vote:"
msgstr "确定在此时，Slogan还是一个空字符串，然后进行投票："

#: ../acs/acs3.md:293
msgid "Release proposal, and the Slogan becomes \"AElf\"."
msgstr "释放提案，随后Slogan变成了“AElf”："

#: ../acs/acs4.rst:2
msgid "ACS4 - Consensus Standard"
msgstr "ACS4 - 共识标准"

#: ../acs/acs4.rst:4
msgid "ACS4 is used to customize consensus mechanisms."
msgstr "ACS4用于定制共识机制。"

#: ../acs/acs4.rst:9
msgid "If you want to customize the consensus mechanism, you need to implement the following five interfaces:"
msgstr "如果想要定制共识机制，需要实现以下五个接口："

#: ../acs/acs4.rst:12
msgid ""
"GetConsensusCommand, whose parameter is a binary array, returns ConsensusCommand defined in acs4.proto. This type is used to indicate the start time of the next block, the block time limit, and the "
"final cut-off time for the account calling GetConsensus Command;"
msgstr "GetConsensusCommand，其参数为二进制数组，返回值为acs4.proto中定义的ConsensusCommand类型，该类型用于提示调用GetConsensusCommand的账户的下一次出块开始时间、出块时间限制和出块最终截止时间；"

#: ../acs/acs4.rst:16
msgid "GetConsensusExtraData, the parameters and return values are binary arrays, which are used to generate consensus block header information through consensus contracts when a new block is produced;"
msgstr "GetConsensusExtraData，参数和返回值都为二进制数组，用来在出块的时候，通过共识合约生成共识区块头信息，该信息被共识合约包装为二进制数组；"

#: ../acs/acs4.rst:19
msgid ""
"GenerateConsensusTransactions, the parameter is a binary array, and the return value is of type TransactionList. It is used to generate a consensus system transaction when a block is generated. Each "
"block will contain only one consensus transaction, which is used to write the latest consensus information to the State database;"
msgstr ""
"GenerateConsensusTransactions，参数为二进制数组，返回值为TransactionList类型，用来在出块的时候，通过共识合约生成共识系统交易，每个区块中都会且仅会包含一个共识交易，用来把最近的共识信息写入State数据库；"

#: ../acs/acs4.rst:24
msgid ""
"ValidateConsensusBeforeExecution, the parameter is a binary array, and the return value is of type ValidationResult, is used to verify whether the consensus information in the block header is correct "
"before the block executes;"
msgstr "ValidateConsensusBeforeExecution，参数为二进制数组，返回值为ValidationResult类型，用来在区块被执行之前验证区块头中的共识信息是否正确；"

#: ../acs/acs4.rst:28
msgid "ValidateConsensusAfterExecution, with the same parameter and return value, is used to verify that the consensus information written to the State is correct after the block executes."
msgstr "ValidateConsensusAfterExecution，参数和返回值同上，用来在区块执行之后验证写入State中的共识信息是否正确。"

#: ../acs/acs4.rst:32
msgid "ConsensusCommand, ValidationResult and TransactionList are defined as:"
msgstr "其中ConsensusCommand、ValidationResult和TransactionList的定义为："

#: ../acs/acs4.rst:54
msgid "The five interfaces defined in ACS4 basically correspond to the five methods of the IConsensusService interface in the AElf.Kernel.Consensus project:"
msgstr "ACS4中所定义的五个接口基本一一对应AElf.Kernel.Consensus项目中IConsensusService接口的五个方法："

#: ../acs/acs4.rst:59
msgid "ACS4"
msgstr ""

#: ../acs/acs4.rst:59
msgid "IConsensusService"
msgstr ""

#: ../acs/acs4.rst:59
msgid "Methodology"
msgstr "原理"

#: ../acs/acs4.rst:59
msgid "The Timing To Call"
msgstr "调用时机"

#: ../acs/acs4.rst:61
msgid "``GetConsensusCommand``"
msgstr ""

#: ../acs/acs4.rst:61
msgid "Task TriggerConsensusAsync"
msgstr ""

#: ../acs/acs4.rst:63
msgid "(ChainContext chainContext);"
msgstr ""

#: ../acs/acs4.rst:61
msgid "When TriggerConsensusAsync is called,"
msgstr ""

#: ../acs/acs4.rst:63
msgid "it will use the account configured by"
msgstr ""

#: ../acs/acs4.rst:65
msgid "the node to call the GetConsensusCommand"
msgstr ""

#: ../acs/acs4.rst:67
msgid "method of the consensus contract"
msgstr ""

#: ../acs/acs4.rst:69
msgid "to obtain block information"
msgstr ""

#: ../acs/acs4.rst:71
msgid "ConsensusCommand), and use it to"
msgstr ""

#: ../acs/acs4.rst:73
msgid "(see IConsensusScheduler implementation)"
msgstr ""

#: ../acs/acs4.rst:75
msgid "."
msgstr ""

#: ../acs/acs4.rst:61
msgid "When the node is started;"
msgstr ""

#: ../acs/acs4.rst:63
msgid "When the BestChainFound-"
msgstr ""

#: ../acs/acs4.rst:65
msgid "EventData event is thrown;"
msgstr ""

#: ../acs/acs4.rst:67
msgid "When the validation of consensus"
msgstr ""

#: ../acs/acs4.rst:69
msgid "data fails and the consensus needs"
msgstr ""

#: ../acs/acs4.rst:71
msgid "to be triggered again (The"
msgstr ""

#: ../acs/acs4.rst:73
msgid "IsReTrigger field of the"
msgstr ""

#: ../acs/acs4.rst:75
msgid "ValidationResult type is true);"
msgstr ""

#: ../acs/acs4.rst:77
msgid "``GetConsensus-``"
msgstr ""

#: ../acs/acs4.rst:79
msgid "``ExtraData``"
msgstr ""

#: ../acs/acs4.rst:77
msgid "Task<byte[]> GetConsensus"
msgstr ""

#: ../acs/acs4.rst:79
msgid "ExtraDataAsync(ChainContext"
msgstr ""

#: ../acs/acs4.rst:81
msgid "chainContext);"
msgstr ""

#: ../acs/acs4.rst:77
msgid "When a node produces a block, it will"
msgstr ""

#: ../acs/acs4.rst:79
msgid "generate block header information for"
msgstr ""

#: ../acs/acs4.rst:81
msgid "the new block by IBlockExtraDataService."
msgstr ""

#: ../acs/acs4.rst:83
msgid "This service is implemented to traverse"
msgstr ""

#: ../acs/acs4.rst:85
msgid "all IBlockExtraDataProvider"
msgstr ""

#: ../acs/acs4.rst:87
msgid "implementations, and they generate"
msgstr ""

#: ../acs/acs4.rst:89
msgid "binary array information into the"
msgstr ""

#: ../acs/acs4.rst:91
msgid "ExtraData field of BlockHeader. The"
msgstr ""

#: ../acs/acs4.rst:93
msgid "consensus block header information is"
msgstr ""

#: ../acs/acs4.rst:95
msgid "provided by ConsensusExtraDataProvider,"
msgstr ""

#: ../acs/acs4.rst:97
msgid "in which the GetConsensusExtraDataAsync"
msgstr ""

#: ../acs/acs4.rst:99
msgid "of the IConsensusService in the"
msgstr ""

#: ../acs/acs4.rst:101
msgid "consensus contract is called, and the"
msgstr ""

#: ../acs/acs4.rst:103
msgid "GetConsensusExtraDataAsync method is"
msgstr ""

#: ../acs/acs4.rst:105
msgid "implemented by calling the"
msgstr ""

#: ../acs/acs4.rst:107
msgid "GetConsensusExtraData in the consensus"
msgstr ""

#: ../acs/acs4.rst:109
msgid "contract."
msgstr ""

#: ../acs/acs4.rst:77 ../acs/acs4.rst:115 ../acs/acs4.rst:129 ../acs/acs4.rst:147
msgid "At the time that the node produces"
msgstr ""

#: ../acs/acs4.rst:79 ../acs/acs4.rst:117 ../acs/acs4.rst:131 ../acs/acs4.rst:149
msgid "a new block."
msgstr ""

#: ../acs/acs4.rst:115
msgid "``GenerateConsensus-``"
msgstr ""

#: ../acs/acs4.rst:117
msgid "``Transactions``"
msgstr ""

#: ../acs/acs4.rst:115
msgid "Task<List<Transaction>>"
msgstr ""

#: ../acs/acs4.rst:117
msgid "GenerateConsensus-"
msgstr ""

#: ../acs/acs4.rst:119
msgid "TransactionsAsync("
msgstr ""

#: ../acs/acs4.rst:121
msgid "ChainContext chainContext);"
msgstr ""

#: ../acs/acs4.rst:115
msgid "In the process of generating new blocks,"
msgstr ""

#: ../acs/acs4.rst:117
msgid "a consensus transaction needs to be"
msgstr ""

#: ../acs/acs4.rst:119
msgid "generated as one of the system"
msgstr ""

#: ../acs/acs4.rst:121
msgid "transactions. The basic principle is the"
msgstr ""

#: ../acs/acs4.rst:123
msgid "same as GetConsensusExtraData."
msgstr ""

#: ../acs/acs4.rst:129 ../acs/acs4.rst:147
msgid "``ValidateConsensus-``"
msgstr ""

#: ../acs/acs4.rst:131
msgid "``BeforeExecution``"
msgstr ""

#: ../acs/acs4.rst:129 ../acs/acs4.rst:147
msgid "Task<bool> ValidateConsensus"
msgstr ""

#: ../acs/acs4.rst:131
msgid "BeforeExecutionAsync("
msgstr ""

#: ../acs/acs4.rst:133
msgid "chainContext, byte[]"
msgstr ""

#: ../acs/acs4.rst:135
msgid "consensusExtraData);"
msgstr ""

#: ../acs/acs4.rst:129
msgid "As long as the IBlockValidationProvider"
msgstr ""

#: ../acs/acs4.rst:131
msgid "interface is implemented, a new block"
msgstr ""

#: ../acs/acs4.rst:133
msgid "validator can be added.  The consensus"
msgstr ""

#: ../acs/acs4.rst:135
msgid "validator is ConsensusValidationProvider"
msgstr ""

#: ../acs/acs4.rst:137
msgid ", where ValidateBlockBeforeExecuteAsync"
msgstr ""

#: ../acs/acs4.rst:139
msgid "is implemented by calling the"
msgstr ""

#: ../acs/acs4.rst:141
msgid "ValidateConsensusBeforeExecution method"
msgstr ""

#: ../acs/acs4.rst:143
msgid "of the consensus contract."
msgstr ""

#: ../acs/acs4.rst:149
msgid "``AfterExecution``"
msgstr ""

#: ../acs/acs4.rst:149
msgid "AfterExecutionAsync"
msgstr ""

#: ../acs/acs4.rst:151
msgid "( ChainContext chainContext,"
msgstr ""

#: ../acs/acs4.rst:153
msgid "byte[] consensusExtraData);"
msgstr ""

#: ../acs/acs4.rst:147
msgid "The implementation of"
msgstr ""

#: ../acs/acs4.rst:149
msgid "ValidateBlockAfterExecuteAsync in"
msgstr ""

#: ../acs/acs4.rst:151
msgid "ConsensusValidationProvider is to call"
msgstr ""

#: ../acs/acs4.rst:153
msgid "the ValidateConsensusAfterExecution"
msgstr ""

#: ../acs/acs4.rst:155
msgid "in the consensus contract."
msgstr ""

#: ../acs/acs4.rst:191
msgid "example"
msgstr "示例"

#: ../acs/acs4.rst:193
msgid "You can refer to the implementation of the AEDPoS contract."
msgstr "可以参考AEDPoS合约的实现。"

#: ../acs/acs5.md:1
msgid "ACS5 - Contract Threshold Standard"
msgstr "ACS5 - 合约调用阈值标准"

#: ../acs/acs5.md:3
msgid "If you want to raise the threshold for using contract, consider implementing ACS5."
msgstr "如果想提高合约的调用门槛，可以考虑实现ACS5。"

#: ../acs/acs5.md:7
msgid "To limit to call a method in a contract, you only need to implement an interface:"
msgstr "要限制对合约中某个方法的调用门槛，仅需要实现一个接口："

#: ../acs/acs5.md:9
msgid "GetMethodCallingThreshold, the parameter is string, and the return value is the MethodCallingThreshold defined in the acs5.proto file."
msgstr "GetMethodCallingThreshold，参数为string，返回值为acs5.proto文件中定义的MethodCallingThreshold类型。"

#: ../acs/acs5.md:11
msgid "If you want to modify the threshold after the contract is deployed, another interface can be implemented:"
msgstr "但是出于合约部署后通过交易来修改门槛，可以实现另一个接口："

#: ../acs/acs5.md:13
msgid "SetMethodCallingThreshold, the parameter is SetMethodCallingThresholdInput."
msgstr "SetMethodCallingThreshold，参数为SetMethodCallingThresholdInput。"

#: ../acs/acs5.md:15
msgid "The definition of MethodCallingThreshold type is:"
msgstr "MethodCallingThreshold类型的定义为："

#: ../acs/acs5.md:28
msgid "The significance of the enumeration ThresholdCheckType is that there are two types of thresholds for contract method calls:"
msgstr "枚举类型ThresholdCheckType存在的意义在于，合约方法调用的门槛有两类："

#: ../acs/acs5.md:30
msgid "It can be called when the balance of a certain token in the account is sufficient, which corresponds to ThresholdCheckType.Balance;"
msgstr "账户某种代币的余额充足即可调用，这种情况对应ThresholdCheckType.Balance；"

#: ../acs/acs5.md:31
msgid ""
"Not only does the balance of a token in the account be required to be sufficient, but the account also needs sufficient authorization for the target contract, which corresponds to The "
"ThresholdCheckType.Allowance."
msgstr "不仅要求该账户某种代币的的余额充足，该账户对目标合约的授权额度也需要充足，这种情况对应ThresholdCheckType.Allowance。"

#: ../acs/acs5.md:32
msgid "SetMethodCallingThresholdInput definition："
msgstr "SetMethodCallingThresholdInput的定义为："

#: ../acs/acs5.md:44
msgid ""
"Similar to ACS1, which uses an automatically generated pre-plugin transaction called ChargeTransactionFees to charge a transaction fee, ACS5 automatically generates a pre-plugin transaction called "
"CheckThreshold to test whether the account that sent the transaction can invoke the corresponding method."
msgstr "类似于ACS1中使用一个自动生成的名为ChargeTransactionFees的pre-plugin交易来收取交易手续费，ACS5会自动生成一个名为CheckThreshold的pre-plugin交易来检验发送该交易的账户是否能够调用对应的方法。"

#: ../acs/acs5.md:46
msgid "The implementation of CheckThreshold:"
msgstr "CheckThreshold的实现为："

#: ../acs/acs5.md:85
msgid ""
"In other words, if the token balance of the sender of the transaction or the amount authorized for the target contract does not reach the set limit, the pre-plugin transaction will throw an exception, "
"thereby it prevents the original transaction from executing."
msgstr "也就是说，如果交易发送者的某种代币余额没达到设定的额度，或对目标合约授权的额度没达到设定的额度，该pre-plugin交易会抛出异常，从而阻止原始交易的执行，以此达到设置调用门槛的效果。"

#: ../acs/acs5.md:89
msgid "As the GetMethodFee of ACS1, you can implement only one GetMethodCallingThreshold method."
msgstr "可以和ACS1的GetMethodFee一样，仅实现一个GetMethodCallingThreshold方法。"

#: ../acs/acs5.md:91
msgid "It can also be achieved by using MappedState<string, MethodCallingThreshold> in the State file:"
msgstr "也可以通过在State文件中一个MappedState<string, MethodCallingThreshold>类型的属性来实现："

#: ../acs/acs5.md:97
msgid "But at the same time, do not forget to configure the call permission of SetMethodCallingThreshold, which requires the definition of an Admin in the State (of course, you can also use ACS3):"
msgstr "不过与此同时不能忘记配置一下SetMethodCallingThreshold的调用权限，这就需要在State中定义一个Admin（当然也可以使用ACS3来完成）："

#: ../acs/acs5.md:103
msgid "The easiest implementation："
msgstr "最简单的实现如下："

#: ../acs/acs5.md:127
msgid "You can test the Foo method defined above."
msgstr "可以针对上面定义的Foo这个方法进行测试。"

#: ../acs/acs5.md:129
msgid "Make a Stub:"
msgstr "准备一个Stub："

#: ../acs/acs5.md:137
msgid "Before setting the threshold, check the current threshold, which should be 0:"
msgstr "在开始设置门槛之前，查一下现在门槛，是0："

#: ../acs/acs5.md:148
msgid "The ELF balance of the caller of Foo should be greater than 1 ELF:"
msgstr "虽然直接进行设置，需要Foo的调用者ELF余额大于1个ELF，才可以进行调用："

#: ../acs/acs5.md:163
msgid "Check the threshold again:"
msgstr "此时再查门槛："

#: ../acs/acs5.md:175
msgid "Send the Foo transaction via an account who has sufficient balance can succeed:"
msgstr "让一个余额充足的账户去调用Foo，可以成功："

#: ../acs/acs5.md:185
msgid "Send the Foo transaction via another account without ELF fails:"
msgstr "换一个没有ELF的账户去调用Foo，失败："

#: ../acs/acs8.md:1
#, fuzzy
msgid "ACS8 - Transaction Resource Fee Standard"
msgstr "ACS1 - 交易费标准"

#: ../acs/acs8.md:3
msgid "ACS8 has some similarities to ACS1, both of them are charge transaction fee standard."
msgstr "ACS8与ACS1有一些类似，都是用来收取交易费的标准。"

#: ../acs/acs8.md:5
msgid "The difference is that ACS1 charges the user a transaction fee, ACS8 charges the called contract, and the transaction fee charged by ACS8 is the specified four tokens: WRITE, READ, NET, TRAFFIC."
msgstr "不同点在于，ACS1向用户收取交易费，ACS8向被调用的合约收取交易费，且ACS8收取的交易费为指定的四种代币：WRITE，READ，NET，TRAFFIC。"

#: ../acs/acs8.md:7
msgid "In another word, if a contract declares that it inherits from ACS8, each transaction in this contract will charge four kinds of resource token."
msgstr "也就是说，如果一个合约声明自己继承自ACS8，每个目标合约为该合约的交易都会根据交易实际执行的数据，对该合约收取数额不定的四种资源币。"

#: ../acs/acs8.md:11
msgid "Only one method is defined in the acs8.proto file:"
msgstr "acs8.proto文件中仅定义了一个方法："

#: ../acs/acs8.md:13
msgid "BuyResourceToken, the parameter is the BuyResourceTokenInput defined in the Proto file."
msgstr "BuyResourceToken，参数为该Proto文件中定义的BuyResourceTokenInput类型。"

#: ../acs/acs8.md:23
msgid ""
"This method can be used to purchase one of the four resource coins, which consumes the ELF balance in the contract account (you can recharge it yourself, or you can collect the user's ELF tokens as a "
"profit to be self-sufficient)."
msgstr "这个方法可以用来购买四种资源币中的一种，消耗的是该合约账户中的ELF余额（可以自行充值，也可以收取用户的ELF代币作为盈利，做到自给自足）。"

#: ../acs/acs8.md:25
msgid ""
"Of course, it is possible for developers to purchase resource token and then directly transfer to the address of this contract via the Transfer method of the Token contract. Therefore, this interface "
"does not have to be implemented."
msgstr "当然，开发者自行购买资源币，然后直接通过Token合约的Transfer方法转到这个合约的地址也是可以的，因此这个方法并不是必须实现。"

#: ../acs/acs8.md:29
msgid "The contract inherited from ACS1 uses a pre-plugin transaction called ChargeTransactionFees for charging transaction fee."
msgstr "继承自ACS1的合约在向用户收取手续费时，利用的是针对被收费交易产生的方法名为ChargeTransactionFees的pre-plugin交易。"

#: ../acs/acs8.md:31
msgid "Because the specific charge amount is determined by the actual consumption of the transaction, the post-plugin generates ChargeResourceToken tansaction to charge resource token."
msgstr ""
"而继承自ACS8的合约在向合约收资源币时，由于具体收费的数额是由实际执行该交易所产生的消耗决定的，因此利用的是针对被收费交易产生的post-plugin交易（即这个新产生的交易在原始交易之后执行），方法名为"
"ChargeResourceToken。"

#: ../acs/acs8.md:33
msgid "The implementation of ChargeResourceToken is also similar to it of ChargeTransactionFees:"
msgstr "ChargeResourceToken的实现也类似ChargeTransactionFees："

#: ../acs/acs8.md:69
msgid ""
"The amount of each resource token should be calculated by AElf.Kernel.FeeCalculation. In detail, A data structure named CalculateFeeCoefficients is defined in token_contract.proto, whose function is to "
"save all coefficients of a polynomial, and every three coefficients are a group, such as a, b, c, which means (b / c) * x ^ a. Each resource token has a polynomial that calculates it. Then according to "
"the polynomial and the actual consumption of the resource, calculate the cost of the resource token. Finally, the cost is used as the parameter of ChargeResourceToken to generate this post-plugin "
"transaction."
msgstr ""
"具体每种资源币该收多少，都在AElf.Kernel.FeeCalculation这个项目中被计算好了，具体来说，就是在token_contract.proto中定义了一个名为CalculateFeeCoefficients的数据结构，其作用是保存一个多项式的所有系数，每三"
"个数字为一组，如a、b、c，表示(b/c)*x^a。然后将这些系数作为CalculateFunction类型的属性之一，结合四种资源币分别针对的交易执行所实际消耗的资源，利用CalculateFeeCoefficients配置好的系数计算多项式，最终把计"
"算结果作为ChargeResourceToken的参数，构造出这个post-plugin交易。"

#: ../acs/acs8.md:71
msgid ""
"In addition, the method of the contract that has been owed cannot be executed before the contract top up resource token. As a result, a pre-plugin transaction is added, similar to the ACS5 pre-plugin "
"transaction, which checks the contract's resource token balance, and the transaction's method name is CheckResourceToken :"
msgstr "除此之外，已欠费的合约的方法在合约重新充值之前不能执行，因此加了一个pre-plugin交易，类似ACS5的pre-plugin交易，对合约的资源币余额进行检查，交易名为CheckResourceToken："

#: ../acs/acs9.md:1
msgid "ACS9 - Contract profit dividend standard"
msgstr "ACS9 - 合约利润分红标准"

#: ../acs/acs9.md:3
msgid "On the AElf's side chain, the contract needs to declare where its profits are going, and implemente ACS9."
msgstr "在AElf的侧链中，合约需要声明自己所得盈利的去向，这时候就需要实现ACS9中定义的一些方法。"

#: ../acs/acs9.md:7
#, fuzzy
msgid "ACS9 contains an method which does not have to be implemented:"
msgstr "包含一个不是必须实现的Action方法："

#: ../acs/acs9.md:9
msgid ""
"TakeContractProfits is used for the developer to collect the profits from the contract. and the profits will be distributed  in this method. There are also other methods for developers to claim "
"profits. However, these methods needs to be approved before deployment/upgrade."
msgstr ""
"TakeContractProfits，用于开发者领取合约的利润，同时会在该方法中分配利润，其参数中需要制定本次领取的利润的代币symbol和数额。开发者也可以使用其他的方法来领取利润。不过相应的逻辑都需要审核通过才可以部署/升"
"级。"

#: ../acs/acs9.md:11
msgid "Two View methods that must be implemented. They are mostly used in the AElf blockchain browser:"
msgstr "两个必须实现以便于显示在AElf区块链浏览器的View方法："

#: ../acs/acs9.md:13
msgid ""
"GetProfitConfig, whose return value is the ProfitConfig defined in acs9.proto, includes the profit token symbol list, the token symbol that the user can lock them to claim the profit, and the portion "
"of the profit that will be donated to the dividend pool each time the developer receives the profit. When reviewing the contract code, you should check if the same ProfitConfig data is actually used "
"for distributing the profits."
msgstr ""
"GetProfitConfig，其返回值是acs9.proto中定义的ProfitConfig数据结构，该结构中包括利润代币symbol列表、用户为了领取利润而锁仓的代币symbol，以及每次开发者领取利润时，其中会捐赠给分红池的部分。在审核该合约的"
"代码时，需要查看实际分配利润的代码逻辑是否使用了同样的ProfitConfig数据。"

#: ../acs/acs9.md:14
msgid "GetProfitsAmount, as the name implies, is used to query the profits of the contract so far, with a return value of type ProfitsMap."
msgstr "GetProfitsAmount，顾名思义，就是查询该合约目前获得的利润，返回值为ProfitsMap类型。"

#: ../acs/acs9.md:16
msgid "ProfitConfig is defined as:"
msgstr "ProfitConfig的定义为："

#: ../acs/acs9.md:26
msgid "The ProfitsMap type is essentially a map from token symbol to the  amount:"
msgstr "ProfitsMap类型实质上就是代币symbol和相应数额的map："

#: ../acs/acs9.md:36
msgid ""
"Here we define a contract. The contract creates a token called APP at the time of initialization and uses the TokenHolder contract to create a token holder bonus scheme with the lock token is "
"designated to APP."
msgstr "在这里我们定义一个合约。该合约会在初始化的时候创建一种名为APP的代币，并使用TokenHolder合约创建出来一个持币人分红方案，锁仓币种指定为APP。"

#: ../acs/acs9.md:38
msgid "The user will be given 10 APP when to sign up."
msgstr "在用户SignUp时，给用户10个APP。"

#: ../acs/acs9.md:40
msgid "Users can purchase 1 APP with 1 ELF using method Deposit, and they can redeem the ELF using the method Withdraw."
msgstr "用户可以使用Deposit方法1：1消耗ELF购买APP，也可以使用Withdraw方法赎回ELF，归还等量的APP给合约。"

#: ../acs/acs9.md:42
msgid "When the user sends the Use transaction, the APP token is consumed."
msgstr "当用户调用Use方法时，会消耗APP代币。"

#: ../acs/acs9.md:44
msgid "Contract initialization is as follows:"
msgstr "合约初始化如下："

#: ../acs/acs9.md:111
msgid "The State.symbol is a singleton of type string, state.Profitconfig is a singleton of type ProfitConfig, and state.profitreceiver is a singleton of type Address."
msgstr "其中，State.Symbol为string类型的单例，State.ProfitConfig为ProfitConfig类型的单例，State.ProfitReceiver为Address类型的单例。"

#: ../acs/acs9.md:113
msgid "The user can use the SighUp method to register and get the bonus. Besides, it will create a archive for him:"
msgstr "用户使用SighUp方法可以注册领币，同时为他建立档案："

#: ../acs/acs9.md:146
msgid "Recharge and redemption:"
msgstr "充值和赎回："

#: ../acs/acs9.md:209
msgid "In the implementation of Use, 1/3 profits are directly transferred into the token holder dividend scheme:"
msgstr "Use的实现中，直接将1/3的盈利打入持币人分红方案："

#: ../acs/acs9.md:251
msgid "The implementation of this contract has been completed. Next, implement ACS9 to perfect the profit distribution:"
msgstr "这个合约本身就实现完成了，接下来实现ACS9的几个方法，来完善这个合约的利润分配环节："

#: ../acs/acs9.md:307
msgid ""
"Since part of the profits from the ACS9 contract transfer to the Token contract and the other transfer to the dividend pool, a TokenHolder Stub and a contract implementing ACS10 Stub are required in "
"the test. Accordingly, the contracts that implements ACS9 or ACS10 need to be deployed. Before the test begins, the contract implementing ACS9 can be initialized by interface "
"IContractInitializationProvider, and sets the dividend pool's name to the other contract's name:"
msgstr ""
"由于实现了ACS9的合约有一部分利润去往TokenHolder合约，还有一部分利润去往一个分红池，因此该测试中，需要一个TokenHolder合约的Stub，以及一个实现了ACS10的合约的Stub。相应地，在测试项目中，需要同时部署实现了"
"ACS9的合约和实现了ACS10的合约。\n"
"在测试开始之前，可以通过实现一个IContractInitializationProvider接口，来初始化实现了ACS9接口的合约，将分红池合约名设置为另外一个实现了ACS10接口的合约："

#: ../acs/acs9.md:332
msgid "Prepare a user account:"
msgstr "准备一个用户账户："

#: ../acs/acs9.md:338
msgid "Prepare some Stubs:"
msgstr "准备一些Stub："

#: ../acs/acs9.md:353
msgid "Then, transfer ELF to the user (TokenContractStub is the Stub of the initial bp who has much ELF) :"
msgstr "然后给用户转点ELF（TokenContractStub为初始bp的token合约的Stub，有很多ELF）："

#: ../acs/acs9.md:365
msgid "Have the user call SignUp to check if he/she has got 10 APP tokens:"
msgstr "让该用户调用SignUp，检查是否得到了10个APP代币："

#: ../acs/acs9.md:373
msgid "Test the recharge method of the contract itself:"
msgstr "测试一下合约本身的充值方法："

#: ../acs/acs9.md:395
msgid "The user locks up 57 APP via the TokenHolder contract in order to obtain profits from the contract:"
msgstr "用户通过TokenHolder合约锁仓57个APP，以便获取持币人分红合约中的利润："

#: ../acs/acs9.md:406
msgid "The Use method is invoked 10 times and 0.3 APP is consumed each time, and finally the user have 50 APP left:"
msgstr "调用10次Use方法，每次消耗0.3个APP，最终用户剩余50个APP："

#: ../acs/acs9.md:424
msgid "Using the TakeContractProfits method, the developer attempts to withdraw 10 ELF as profits. The 10 ELF will be transferred to the developer in this method:"
msgstr "开发者使用TakeContractProfits方法，试图提取10个ELF作为利润，此时会在合约中自动分配该10个ELF："

#: ../acs/acs9.md:451
msgid "Next check the profit distribution results. The dividend pool should be allocated 0.1 ELF:"
msgstr ""
"接下来检查利润分配结果。\n"
"分红池此时应该分配到了0.1个ELF："

#: ../acs/acs9.md:472
msgid "The user receives 1 ELF from the token holder dividend scheme:"
msgstr "用户领取持币人分红方案中的利润，得到1个ELF："

#: ../acs/acs9.md:485
msgid "Finally, let's test the Withdraw method."
msgstr "最后顺便测试一下合约本身的赎回方法："

#: ../acs/index.rst:4
msgid "Acs1 - Transaction Fee Standard"
msgstr "ACS1 - 交易费标准"

#: ../acs/index.rst:4
msgid "Acs2 - Parallel Execution Standard"
msgstr "ACS2 - 并行执行标准"

#: ../acs/index.rst:4
msgid "Acs3 - Contract Proposal Standard"
msgstr "ACS3 - 提案合约标准"

#: ../acs/index.rst:4
msgid "Acs4 - Consensus Standard"
msgstr "ACS4 - 共识标准"

#: ../acs/index.rst:4
msgid "Acs5 - Contract Threshold Standard"
msgstr "ACS5 - 合约调用阈值标准"

#: ../acs/index.rst:4
msgid "Acs8 - Transaction Resource Token Fee Standard"
msgstr "ACS1 - 交易费标准"

#: ../acs/index.rst:4
msgid "Acs9 - Contract profit dividend standard"
msgstr "ACS9 - 合约利润分红标准"

#: ../acs/index.rst:4
msgid "Acs10 - Dividend pool standard"
msgstr "ACS10 - 分红池标准"

#: ../acs/index.rst:2 ../acs/index.rst:4
msgid "Acs Introduction"
msgstr ""

#~ msgid "Used to test"
#~ msgstr "用来测试"

#~ msgid "ACS8 - Resource Transaction Fee Standard"
#~ msgstr "ACS8 - 资源交易费标准"
